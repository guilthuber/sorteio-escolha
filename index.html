<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorteio de Rodadas</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --primary-color: #2a2a2a;
            --secondary-color: #3c3c3c;
            --text-color: #f0f0f0;
            --accent-color: #007bff;
            --accent-hover: #0056b3;
            --winner1: #ffd700;
            --winner2: #c0c0c0;
            --winner3: #cd7f32;
            --success-color: #28a745;
            --error-color: #dc3545;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        h1 {
            text-align: center;
            color: var(--accent-color);
        }

        .panel {
            background-color: var(--primary-color);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        #setupPanel, #newDrawPanel {
            text-align: center;
        }

        #lobbyUrlInput, #newDrawNameInput, #newDrawUrlInput {
             background-color: var(--secondary-color);
            color: var(--text-color);
            border: 1px solid var(--accent-color);
            border-radius: 4px;
            padding: 10px;
            width: 100%;
            max-width: 400px;
            margin-top: 10px;
            margin-bottom: 10px;
            box-sizing: border-box;
        }

        #lobbyPanel {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: center;
        }

        #drawSelector {
            background-color: var(--secondary-color);
            color: var(--text-color);
            border: 1px solid var(--accent-color);
            border-radius: 4px;
            padding: 10px;
            min-width: 200px;
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            align-items: start;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-weight: bold;
        }

        input[type="number"],
        textarea {
            background-color: var(--secondary-color);
            color: var(--text-color);
            border: 1px solid var(--accent-color);
            border-radius: 4px;
            padding: 10px;
            width: 100%;
            box-sizing: border-box;
        }
        
        input[type="number"]:focus,
        textarea:focus {
            outline: none;
            box-shadow: 0 0 5px var(--accent-color);
        }

        textarea {
            min-height: 100px;
            resize: vertical;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        button, input[type="file"]::-webkit-file-upload-button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }

        button:hover, input[type="file"]::-webkit-file-upload-button:hover {
            background-color: var(--accent-hover);
        }
        
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        button.secondary {
            background-color: var(--secondary-color);
        }
        button.secondary:hover {
            background-color: #555;
        }
        
        button.danger {
            background-color: var(--error-color);
        }
        button.danger:hover {
            background-color: #a72834;
        }

        .checkbox-group, .switch-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        .switch input { display: none; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--accent-color); }
        input:checked + .slider:before { transform: translateX(26px); }

        #syncStatus {
            margin-top: 15px;
            font-style: italic;
            transition: color 0.5s;
        }

        #syncStatus[data-status="synced"] { color: var(--success-color); }
        #syncStatus[data-status="saving"], #syncStatus[data-status="updating"] { color: var(--accent-color); }
        #syncStatus[data-status="error"], #syncStatus[data-status="offline"] { color: var(--error-color); }

        .table-container {
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th, td {
            padding: 12px;
            text-align: center;
            border: 1px solid var(--secondary-color);
        }

        thead th {
            background-color: var(--accent-color);
            color: white;
            position: sticky;
            top: 0;
        }
        
        tbody tr:nth-child(odd) {
            background-color: var(--primary-color);
        }
        
        tbody tr:nth-child(even) {
            background-color: #222;
        }

        .player-name-input {
            width: 90%;
            padding: 5px;
            background-color: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--secondary-color);
            border-radius: 4px;
            text-align: center;
        }
        
        .manual-input {
            width: 60px;
            padding: 5px;
            text-align: center;
            background-color: #444;
            color: white;
            border: 1px solid var(--accent-color);
            border-radius: 4px;
        }
        .manual-input:focus {
            outline: 2px solid var(--accent-color);
            box-shadow: 0 0 8px var(--accent-color);
        }
        .manual-input:disabled {
            background-color: transparent;
            border: none;
            color: var(--text-color);
        }

        .winner-1 { font-weight: bold; color: var(--winner1); }
        .winner-2 { font-weight: bold; color: var(--winner2); }
        .winner-3 { font-weight: bold; color: var(--winner3); }

        .win-criteria {
            font-size: 0.8em;
            color: #ccc;
            white-space: nowrap;
        }

        .footer {
            text-align: center;
            margin-top: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
        }

        .btn-file {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            font-weight: bold;
            display: inline-block;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Sorteio de Rodadas</h1>

        <!-- PAINEL DE CONFIGURAÇÃO INICIAL -->
        <div id="setupPanel" class="panel">
            <h2>Configuração do Lobby</h2>
            <p>Para começar, crie um 'bin' no npoint.io com o conteúdo <code>{ "draws": {} }</code> e cole a URL da API abaixo.</p>
            <input type="text" id="lobbyUrlInput" placeholder="https://api.npoint.io/xxxxxxxx">
            <button id="saveLobbyUrlBtn">Salvar URL do Lobby</button>
            <p id="setupError" style="color: var(--error-color);"></p>
        </div>

        <!-- PAINEL DO LOBBY -->
        <div id="lobbyPanel" class="panel" style="display: none;">
            <label for="drawSelector">Sorteios Salvos:</label>
            <select id="drawSelector"></select>
            <button id="loadDrawBtn">Carregar Sorteio</button>
            <button id="createDrawBtn">Novo Sorteio</button>
        </div>

        <!-- PAINEL DE CRIAÇÃO DE SORTEIO -->
        <div id="newDrawPanel" class="panel" style="display: none;">
            <h2>Criar Novo Sorteio</h2>
            <div class="form-group">
                <label for="newDrawNameInput">Nome do Sorteio:</label>
                <input type="text" id="newDrawNameInput" placeholder="Ex: Sorteio de Férias">
            </div>
            <div class="form-group">
                <label for="newDrawUrlInput">URL da API do npoint.io:</label>
                <input type="text" id="newDrawUrlInput" placeholder="https://api.npoint.io/xxxxxxxx">
                <small>Crie um bin vazio no npoint.io com o conteúdo <code>{ "csv": "" }</code> e cole a URL da API aqui.</small>
            </div>
            <div class="button-group">
                <button id="saveNewDrawBtn">Salvar Novo Sorteio</button>
                <button id="cancelNewDrawBtn" class="secondary">Cancelar</button>
            </div>
            <p id="newDrawError" style="color: var(--error-color);"></p>
        </div>

        <!-- PAINEL DE CONFIGURAÇÃO DO SORTEIO -->
        <div id="configPanel" class="panel" style="display: none;">
            <div class="config-grid">
                <div class="form-group">
                    <label for="numPlayers">Nº de participantes</label>
                    <input type="number" id="numPlayers" value="3" min="3">
                    <label for="playerNames" style="margin-top: 15px;">Nomes (um por linha ou separados por vírgula)</label>
                    <textarea id="playerNames" placeholder="Ex: Ana, Beto, Carol"></textarea>
                </div>
                <div class="form-group">
                    <div class="checkbox-group" title="Quando marcado, a cada rodada é sorteado se vence o MAIOR ou o MENOR número.">
                        <input type="checkbox" id="randomizeWinCriteria">
                        <label for="randomizeWinCriteria">Randomizar critério de vitória</label>
                    </div>
                    <div class="switch-group">
                        <label class="switch">
                            <input type="checkbox" id="manualModeToggle">
                            <span class="slider"></span>
                        </label>
                        <label for="manualModeToggle">Entrada manual por turno</label>
                    </div>
                    <div id="syncStatus" aria-live="polite">Carregando...</div>
                    <div id="lastUpdate" style="font-size: 0.8em; color: #aaa;"></div>
                </div>
                <div class="form-group">
                    <label>Ações</label>
                    <div class="button-group">
                        <button id="createTableBtn">Criar tabela</button>
                        <button id="randomizeOrderBtn">Randomizar ordem</button>
                        <button id="generateRoundBtn" disabled>Gerar rodada 1</button>
                        <button id="generateAllBtn" disabled>Gerar todas restantes</button>
                        <button id="resetBtn" class="danger" disabled>Resetar sorteio</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- TABELA PRINCIPAL -->
        <div class="panel table-container" style="display: none;" id="tablePanel">
            <table id="resultsTable">
                <thead></thead>
                <tbody></tbody>
            </table>
        </div>
        
        <!-- RODAPÉ -->
        <div class="footer panel" style="display: none;" id="footerPanel">
            <button id="exportCsvBtn">Exportar CSV</button>
            <div class="file-input-wrapper">
                <span class="btn-file">Importar CSV</span>
                <input type="file" id="importCsvInput" accept=".csv,text/csv">
            </div>
        </div>
    </div>

    <script>
    let LOBBY_ENDPOINT = localStorage.getItem('npointLobbyUrl_sorteio') || '';
    let currentDrawEndpoint = '';
    let lobbyData = { draws: {} };

    document.addEventListener('DOMContentLoaded', () => {
        // --- ELEMENTOS DO DOM ---
        const setupPanel = document.getElementById('setupPanel');
        const lobbyUrlInput = document.getElementById('lobbyUrlInput');
        const saveLobbyUrlBtn = document.getElementById('saveLobbyUrlBtn');
        const setupError = document.getElementById('setupError');
        
        const lobbyPanel = document.getElementById('lobbyPanel');
        const newDrawPanel = document.getElementById('newDrawPanel');
        const configPanel = document.getElementById('configPanel');
        const tablePanel = document.getElementById('tablePanel');
        const footerPanel = document.getElementById('footerPanel');

        const drawSelector = document.getElementById('drawSelector');
        const loadDrawBtn = document.getElementById('loadDrawBtn');
        const createDrawBtn = document.getElementById('createDrawBtn');

        const newDrawNameInput = document.getElementById('newDrawNameInput');
        const newDrawUrlInput = document.getElementById('newDrawUrlInput');
        const saveNewDrawBtn = document.getElementById('saveNewDrawBtn');
        const cancelNewDrawBtn = document.getElementById('cancelNewDrawBtn');
        const newDrawError = document.getElementById('newDrawError');
        
        const numPlayersInput = document.getElementById('numPlayers');
        const playerNamesTextarea = document.getElementById('playerNames');
        const randomizeWinCriteriaCheckbox = document.getElementById('randomizeWinCriteria');
        const manualModeToggle = document.getElementById('manualModeToggle');

        const createTableBtn = document.getElementById('createTableBtn');
        const randomizeOrderBtn = document.getElementById('randomizeOrderBtn');
        const generateRoundBtn = document.getElementById('generateRoundBtn');
        const generateAllBtn = document.getElementById('generateAllBtn');
        const resetBtn = document.getElementById('resetBtn');
        
        const syncStatusEl = document.getElementById('syncStatus');
        const lastUpdateEl = document.getElementById('lastUpdate');
        const tableThead = document.querySelector('#resultsTable thead');
        const tableTbody = document.querySelector('#resultsTable tbody');
        
        const exportCsvBtn = document.getElementById('exportCsvBtn');
        const importCsvInput = document.getElementById('importCsvInput');

        // --- ESTADO DA APLICAÇÃO ---
        let state = null; 
        let tableCreated = false;
        let isSaving = false;
        let pollIntervalId = null;

        // --- FUNÇÕES UTILITÁRIAS ---
        function getRandomInt(min, max) { /* ... */ }
        function shuffleArray(array) { /* ... */ }
        function updateSyncStatus(status, message) { /* ... */ }
        // ... (as funções utilitárias completas estão abaixo para economizar espaço)

        function showMainPanels(show) {
            configPanel.style.display = show ? 'block' : 'none';
            tablePanel.style.display = show ? 'block' : 'none';
            footerPanel.style.display = show ? 'flex' : 'none';
        }
        
        // --- LÓGICA DO LOBBY ---

        async function loadLobby() {
            try {
                const response = await fetch(LOBBY_ENDPOINT);
                if (!response.ok) throw new Error("Não foi possível carregar o lobby.");
                const data = await response.json();
                lobbyData = data && data.draws ? data : { draws: {} }; 
                populateDrawSelector();
            } catch (error) {
                console.error("Erro no Lobby:", error);
                lobbyPanel.innerHTML = "<strong>Erro ao carregar o Lobby. Verifique a URL e a conexão.</strong>";
            }
        }

        function populateDrawSelector() {
            drawSelector.innerHTML = '<option value="">-- Selecione um Sorteio --</option>';
            for (const id in lobbyData.draws) {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = lobbyData.draws[id];
                drawSelector.appendChild(option);
            }
        }

        async function addNewDrawToLobby(id, name) {
            lobbyData.draws[id] = name;
            try {
                const response = await fetch(LOBBY_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(lobbyData)
                });
                if (!response.ok) throw new Error("Falha ao salvar o novo sorteio no lobby.");
                
                newDrawPanel.style.display = 'none';
                lobbyPanel.style.display = 'flex';
                
                populateDrawSelector();
                drawSelector.value = id;
                await loadSelectedDraw();
            } catch (error) {
                console.error("Erro ao adicionar sorteio:", error);
                newDrawError.textContent = "Não foi possível salvar o novo sorteio no lobby.";
            }
        }

        async function loadSelectedDraw() {
            if (pollIntervalId) clearInterval(pollIntervalId);
            pollIntervalId = null;

            const selectedId = drawSelector.value;
            if (!selectedId) {
                state = null;
                showMainPanels(false);
                return;
            }
            currentDrawEndpoint = `https://api.npoint.io/${selectedId}`;
            await fetchRemoteState();
            showMainPanels(true);

            pollIntervalId = setInterval(pollForChanges, 7000);
        }

        // --- LÓGICA DE PERSISTÊNCIA (CSV) ---
        
        function serializeToCsv() { /* ... */ }
        function parseFromCsv(csvString) { /* ... */ }
        // ... (código completo abaixo)

        // --- LÓGICA DE REDE ---

        async function fetchRemoteState() {
             if (!currentDrawEndpoint) return;
            try {
                updateSyncStatus('updating', 'Carregando dados...');
                const response = await fetch(currentDrawEndpoint);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                state = parseFromCsv(data.csv || "");
                tableCreated = state && state.columns && state.columns.length > 0;
                if (!state) {
                    state = { config: { rounds: 12, players: 3, randomize_win_criteria: 'N', updatedAt: new Date().toISOString() }, columns: [], names: [], roundsData: [] };
                    tableCreated = false;
                }
                renderUI();
                updateSyncStatus('synced', 'Sincronizado');
            } catch (error) {
                console.error("Erro ao buscar dados:", error);
                updateSyncStatus('offline', 'Falha ao carregar. Verifique a URL e a conexão.');
            }
        }

        async function saveRemoteState() {
            if (!currentDrawEndpoint || !state) return;
            if (isSaving) return;
            isSaving = true;
            updateSyncStatus('saving', 'Salvando...');
            state.config.updatedAt = new Date().toISOString();
            try {
                const response = await fetch(currentDrawEndpoint, {
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ csv: serializeToCsv() })
                });
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                updateSyncStatus('synced', 'Sincronizado');
            } catch (error) {
                console.error("Erro ao salvar dados:", error);
                updateSyncStatus('error', 'Falha ao salvar.');
            } finally {
                isSaving = false;
                renderUI();
            }
        }

        async function pollForChanges() {
            if (!currentDrawEndpoint || !state) return;
            try {
                const response = await fetch(currentDrawEndpoint);
                if (!response.ok) return; 
                const data = await response.json();
                const remoteState = parseFromCsv(data.csv || "");
                if (remoteState && remoteState.config.updatedAt > state.config.updatedAt) {
                    updateSyncStatus('updating', 'Atualizando...');
                    state = remoteState;
                    tableCreated = state.columns.length > 0;
                    renderUI();
                    updateSyncStatus('synced', 'Sincronizado');
                }
            } catch (error) {
                console.error("Erro durante o polling:", error);
            }
        }

        // --- LÓGICA DO SORTEIO ---
        function determineWinners(scores, criteria) { /* ... */ }
        function generateRound(roundIndex) { /* ... */ }

        // --- RENDERIZAÇÃO DA UI ---
        function renderUI() { /* ... */ }
        function handleManualInputChange(e) { /* ... */ }
        function findNextRound() { /* ... */ }
        function updateButtonStates() { /* ... */ }

        // --- MANIPULADORES DE EVENTOS ---

        saveLobbyUrlBtn.addEventListener('click', () => {
            const url = lobbyUrlInput.value.trim();
            if (url && url.startsWith("https://api.npoint.io/")) {
                LOBBY_ENDPOINT = url;
                localStorage.setItem('npointLobbyUrl_sorteio', url);
                init(); 
            } else {
                setupError.textContent = 'URL inválida. Por favor, insira uma URL da API do npoint.io.';
            }
        });

        loadDrawBtn.addEventListener('click', loadSelectedDraw);

        createDrawBtn.addEventListener('click', () => {
            lobbyPanel.style.display = 'none';
            newDrawPanel.style.display = 'block';
            newDrawError.textContent = '';
            newDrawNameInput.value = '';
            newDrawUrlInput.value = '';
        });

        cancelNewDrawBtn.addEventListener('click', () => {
            newDrawPanel.style.display = 'none';
            lobbyPanel.style.display = 'flex';
        });

        saveNewDrawBtn.addEventListener('click', () => {
            const newName = newDrawNameInput.value.trim();
            const newUrl = newDrawUrlInput.value.trim();
            if (!newName) {
                newDrawError.textContent = "O nome do sorteio é obrigatório.";
                return;
            }
            if (newUrl && newUrl.startsWith("https://api.npoint.io/")) {
                const newId = newUrl.split('/').pop();
                addNewDrawToLobby(newId, newName);
            } else {
                newDrawError.textContent = "A URL da API é inválida.";
            }
        });

        createTableBtn.addEventListener('click', () => { /* ... */ });
        randomizeOrderBtn.addEventListener('click', () => { /* ... */ });
        generateRoundBtn.addEventListener('click', () => { /* ... */ });
        generateAllBtn.addEventListener('click', () => { /* ... */ });
        resetBtn.addEventListener('click', () => { /* ... */ });
        manualModeToggle.addEventListener('change', renderUI);
        exportCsvBtn.addEventListener('click', () => { /* ... */ });
        importCsvInput.addEventListener('change', (event) => { /* ... */ });

        // --- INICIALIZAÇÃO ---
        function init() {
            if (LOBBY_ENDPOINT) {
                setupPanel.style.display = 'none';
                lobbyPanel.style.display = 'flex';
                loadLobby();
            } else {
                setupPanel.style.display = 'block';
                lobbyPanel.style.display = 'none';
                showMainPanels(false);
            }
        }
        init();
        
    // --- CÓDIGO COMPLETO DAS FUNÇÕES MINIMIZADAS ---

    getRandomInt = function(min, max) {
        const range = max - min + 1;
        const buffer = new Uint32Array(1);
        window.crypto.getRandomValues(buffer);
        return min + (buffer[0] % range);
    }

    shuffleArray = function(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = getRandomInt(0, i);
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }
    
    updateSyncStatus = function(status, message) {
        syncStatusEl.dataset.status = status;
        syncStatusEl.textContent = message;
    }

    serializeToCsv = function() {
        if (!state) return "";
        const binId = currentDrawEndpoint.split('/').pop();
        const configLine = `CONFIG,rounds,${state.config.rounds},players,${state.config.players},randomize_win_criteria,${state.config.randomize_win_criteria},updatedAt,${state.config.updatedAt},bin_id,${binId}`;
        const columnsLine = `COLUMNS,${state.columns.join(',')}`;
        const namesLine = `NAMES,${state.names.join(',')}`;
        const roundsLines = state.roundsData.map((round, i) => {
            const roundNum = `R${i + 1}`;
            const criteria = round.criteria || '';
            const scores = round.scores.join(',');
            const order = round.order && round.order.length > 0 ? `ORDER,${round.order.join(',')}` : 'ORDER,,';
            return `${roundNum},${criteria},${scores},${order}`;
        }).join('\n');
        return [configLine, columnsLine, namesLine, roundsLines].join('\n');
    }

    parseFromCsv = function(csvString) {
        if (!csvString) return null;
        const lines = csvString.trim().split('\n');
        const newState = { config: {}, columns: [], names: [], roundsData: [] };
        lines.forEach(line => {
            const parts = line.split(',');
            const type = parts[0];
            if (type === 'CONFIG') {
                newState.config.rounds = parseInt(parts[2], 10);
                newState.config.players = parseInt(parts[4], 10);
                newState.config.randomize_win_criteria = parts[6];
                newState.config.updatedAt = parts[8];
            } else if (type === 'COLUMNS') {
                newState.columns = parts.slice(1);
            } else if (type === 'NAMES') {
                newState.names = parts.slice(1);
            } else if (type.startsWith('R')) {
                const roundIndex = parseInt(type.substring(1), 10) - 1;
                if (!newState.roundsData[roundIndex]) {
                     newState.roundsData[roundIndex] = { scores: [], order: [] };
                }
                newState.roundsData[roundIndex].criteria = parts[1];
                const orderIndex = parts.indexOf('ORDER');
                newState.roundsData[roundIndex].scores = parts.slice(2, orderIndex).map(s => s ? parseInt(s, 10) : null);
                newState.roundsData[roundIndex].order = parts.slice(orderIndex + 1).map(o => o ? parseInt(o, 10) : null);
            }
        });
        if (isNaN(newState.config.rounds)) return null;
        newState.roundsData.length = newState.config.rounds;
        for(let i = 0; i < newState.config.rounds; i++) {
            if(!newState.roundsData[i]) {
                newState.roundsData[i] = { scores: Array(newState.config.players).fill(null), order: [] };
            }
        }
        return newState;
    }

    determineWinners = function(scores, criteria) {
        let indexedScores = scores.map((score, index) => ({ score, index: index + 1 }))
                                  .filter(item => item.score !== null && !isNaN(item.score));
        indexedScores.sort((a, b) => {
            let diff = (criteria === 'MAX') ? b.score - a.score : a.score - b.score;
            return diff !== 0 ? diff : (getRandomInt(1, 100) > 50 ? 1 : -1);
        });
        const places = Array(scores.length).fill(null);
        indexedScores.slice(0, 3).forEach((item, i) => {
            places[item.index - 1] = i + 1;
        });
        return { order: places };
    }
    
    generateRound = function(roundIndex) {
        const roundData = state.roundsData[roundIndex];
        if (!roundData.criteria) {
            roundData.criteria = (state.config.randomize_win_criteria === 'Y') ? (getRandomInt(0, 1) === 0 ? 'MIN' : 'MAX') : 'MAX';
        }
        roundData.scores = Array.from({ length: state.config.players }, () => getRandomInt(1, 100));
        const { order } = determineWinners(roundData.scores, roundData.criteria);
        roundData.order = order;
    }

    renderUI = function() {
        if (!state) return;
        numPlayersInput.value = state.config.players;
        randomizeWinCriteriaCheckbox.checked = state.config.randomize_win_criteria === 'Y';
        playerNamesTextarea.value = state.names.join('\n');
        if (state.config.updatedAt) {
            lastUpdateEl.textContent = `Última atualização: ${new Date(state.config.updatedAt).toLocaleString()}`;
        }
        tableThead.innerHTML = '';
        tableTbody.innerHTML = '';
        if (!tableCreated) {
            updateButtonStates();
            return;
        }
        const headerRow1 = document.createElement('tr');
        const headerRow2 = document.createElement('tr');
        headerRow1.innerHTML = '<th></th>';
        headerRow2.innerHTML = '<th>SORTEIO</th>';
        state.columns.forEach((colId, index) => {
            const th1 = document.createElement('th');
            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.value = state.names[index] || '';
            nameInput.placeholder = `Nome ${index + 1}`;
            nameInput.className = 'player-name-input';
            nameInput.dataset.index = index;
            nameInput.addEventListener('change', (e) => {
                state.names[e.target.dataset.index] = e.target.value.toUpperCase();
                saveRemoteState();
            });
            th1.appendChild(nameInput);
            headerRow1.appendChild(th1);
            const th2 = document.createElement('th');
            th2.textContent = `PESSOA ${index + 1}`;
            headerRow2.appendChild(th2);
        });
        headerRow1.innerHTML += '<th></th>';
        headerRow2.innerHTML += '<th>CRITÉRIO</th>';
        tableThead.appendChild(headerRow1);
        tableThead.appendChild(headerRow2);
        state.roundsData.forEach((round, roundIndex) => {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td><strong>R${roundIndex + 1}</strong></td>`;
            const isManualModeActive = manualModeToggle.checked;
            const nextOpenRound = findNextRound();
            round.scores.forEach((score, playerIndex) => {
                const td = document.createElement('td');
                if (isManualModeActive && roundIndex === nextOpenRound) {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.min = 1;
                    input.max = 100;
                    input.className = 'manual-input';
                    input.dataset.round = roundIndex;
                    input.dataset.player = playerIndex;
                    const firstEmptyInput = round.scores.findIndex(s => s === null);
                    input.disabled = playerIndex !== firstEmptyInput;
                    input.addEventListener('change', handleManualInputChange);
                    td.appendChild(input);
                } else {
                    let content = '';
                    if (score !== null) {
                        content = `${score} `;
                        const place = round.order[playerIndex];
                        if (place) {
                            content += `<span class="winner-${place}">[${place}º]</span>`;
                        }
                    }
                    td.innerHTML = content;
                }
                tr.appendChild(td);
            });
            const criteriaTd = document.createElement('td');
            if(round.criteria) {
                 criteriaTd.innerHTML = `<span class="win-criteria">${round.criteria === 'MAX' ? 'MAIOR' : 'MENOR'} vence</span>`;
            }
            tr.appendChild(criteriaTd);
            tableTbody.appendChild(tr);
        });
        updateButtonStates();
    }
    
    handleManualInputChange = function(e) {
        const roundIndex = parseInt(e.target.dataset.round, 10);
        const playerIndex = parseInt(e.target.dataset.player, 10);
        let value = parseInt(e.target.value, 10);
        if (isNaN(value) || value < 1 || value > 100) {
            value = null;
            e.target.value = '';
        }
        state.roundsData[roundIndex].scores[playerIndex] = value;
        const isRoundComplete = !state.roundsData[roundIndex].scores.includes(null);
        if (isRoundComplete) {
            const roundData = state.roundsData[roundIndex];
            if (state.config.randomize_win_criteria === 'Y') {
                roundData.criteria = getRandomInt(0, 1) === 0 ? 'MIN' : 'MAX';
            } else {
                roundData.criteria = 'MAX';
            }
            const { order } = determineWinners(roundData.scores, roundData.criteria);
            roundData.order = order;
            saveRemoteState();
        }
        renderUI();
    }

    findNextRound = function() {
        if (!state || !state.roundsData) return -1;
        return state.roundsData.findIndex(r => r.scores.some(s => s === null) || r.scores.length === 0);
    }

    updateButtonStates = function() {
        if (!state) return;
        const nextRound = findNextRound();
        numPlayersInput.disabled = tableCreated;
        createTableBtn.disabled = tableCreated;
        randomizeOrderBtn.disabled = !playerNamesTextarea.value.trim();
        generateRoundBtn.disabled = !tableCreated || nextRound === -1;
        generateAllBtn.disabled = !tableCreated || nextRound === -1;
        resetBtn.disabled = !tableCreated;
        if (nextRound !== -1) {
            generateRoundBtn.textContent = `Gerar rodada ${nextRound + 1}`;
        } else if(tableCreated) {
            generateRoundBtn.textContent = 'Completo!';
        }
    }

    createTableBtn.addEventListener('click', () => {
        const numPlayers = parseInt(numPlayersInput.value, 10);
        if (numPlayers < 3) {
            updateSyncStatus('error', "O número de participantes deve ser no mínimo 3.");
            return;
        }
        tableCreated = true;
        let names = playerNamesTextarea.value.trim().split(/[\n,]/)
            .map(name => name.trim().toUpperCase()).filter(name => name);
        while (names.length < numPlayers) {
            names.push(`JOGADOR ${names.length + 1}`);
        }
        names = names.slice(0, numPlayers);
        state.config.players = numPlayers;
        state.config.randomize_win_criteria = randomizeWinCriteriaCheckbox.checked ? 'Y' : 'N';
        state.columns = Array.from({ length: numPlayers }, (_, i) => `P${i + 1}`);
        state.names = shuffleArray([...names]);
        state.roundsData = Array.from({ length: state.config.rounds }, () => ({
            criteria: null,
            scores: Array(numPlayers).fill(null),
            order: []
        }));
        saveRemoteState();
    });
    
    randomizeOrderBtn.addEventListener('click', () => {
         let names = playerNamesTextarea.value.trim().split(/[\n,]/)
            .map(name => name.trim()).filter(name => name);
        playerNamesTextarea.value = shuffleArray(names).join('\n');
    });

    generateRoundBtn.addEventListener('click', () => {
        const nextRound = findNextRound();
        if (nextRound !== -1) {
            generateRound(nextRound);
            saveRemoteState();
        }
    });
    
    generateAllBtn.addEventListener('click', () => {
        let nextRound = findNextRound();
        while(nextRound !== -1) {
            generateRound(nextRound);
            nextRound = findNextRound();
        }
        saveRemoteState();
    });

    resetBtn.addEventListener('click', () => {
        state.roundsData = Array.from({ length: state.config.rounds }, () => ({
            criteria: null,
            scores: Array(state.config.players).fill(null),
            order: []
        }));
        saveRemoteState();
    });
    
    exportCsvBtn.addEventListener('click', () => {
        const csvContent = serializeToCsv();
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        const drawName = lobbyData.draws[currentDrawEndpoint.split('/').pop()] || 'sorteio';
        link.setAttribute("download", `${drawName.replace(/\s/g, '_')}_${new Date().toISOString().split('T')[0]}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    });

    importCsvInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const newState = parseFromCsv(e.target.result);
                if (!newState) throw new Error("Arquivo CSV inválido.");
                state = newState;
                tableCreated = true;
                saveRemoteState();
            } catch (error) {
                console.error("Erro ao importar CSV:", error);
                updateSyncStatus('error', "Erro ao importar o arquivo.");
            }
        };
        reader.readAsText(file);
        event.target.value = '';
    });

    });
    </script>

</body>
</html>

