<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorteio de Rodadas</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --primary-color: #2a2a2a;
            --secondary-color: #3c3c3c;
            --text-color: #f0f0f0;
            --accent-color: #007bff;
            --accent-hover: #0056b3;
            --winner1: #ffd700;
            --winner2: #c0c0c0;
            --winner3: #cd7f32;
            --success-color: #28a745;
            --error-color: #dc3545;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        h1 {
            text-align: center;
            color: var(--accent-color);
        }

        .panel {
            background-color: var(--primary-color);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        #newDrawPanel {
            text-align: center;
        }

        #newDrawNameInput {
             background-color: var(--secondary-color);
            color: var(--text-color);
            border: 1px solid var(--accent-color);
            border-radius: 4px;
            padding: 10px;
            width: 100%;
            max-width: 400px;
            margin-top: 10px;
            margin-bottom: 10px;
            box-sizing: border-box;
        }

        #lobbyPanel {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: center;
        }

        #drawSelector {
            background-color: var(--secondary-color);
            color: var(--text-color);
            border: 1px solid var(--accent-color);
            border-radius: 4px;
            padding: 10px;
            min-width: 200px;
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            align-items: start;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-weight: bold;
        }

        input[type="number"],
        textarea {
            background-color: var(--secondary-color);
            color: var(--text-color);
            border: 1px solid var(--accent-color);
            border-radius: 4px;
            padding: 10px;
            width: 100%;
            box-sizing: border-box;
        }
        
        input[type="number"]:focus,
        textarea:focus {
            outline: none;
            box-shadow: 0 0 5px var(--accent-color);
        }

        textarea {
            min-height: 100px;
            resize: vertical;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        button, input[type="file"]::-webkit-file-upload-button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }

        button:hover, input[type="file"]::-webkit-file-upload-button:hover {
            background-color: var(--accent-hover);
        }
        
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        button.secondary {
            background-color: var(--secondary-color);
        }
        button.secondary:hover {
            background-color: #555;
        }
        
        button.danger {
            background-color: var(--error-color);
        }
        button.danger:hover {
            background-color: #a72834;
        }
        
        button.confirm-btn {
            padding: 5px 10px;
            margin-left: 5px;
            font-size: 0.8em;
            background-color: var(--success-color);
        }
        button.confirm-btn:hover {
            background-color: #218838;
        }


        .checkbox-group, .switch-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        .switch input { display: none; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--accent-color); }
        input:checked + .slider:before { transform: translateX(26px); }

        #syncStatus {
            margin-top: 15px;
            font-style: italic;
            transition: color 0.5s;
        }

        #syncStatus[data-status="synced"] { color: var(--success-color); }
        #syncStatus[data-status="saving"], #syncStatus[data-status="updating"] { color: var(--accent-color); }
        #syncStatus[data-status="error"], #syncStatus[data-status="offline"] { color: var(--error-color); }

        .table-container {
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th, td {
            padding: 12px;
            text-align: center;
            border: 1px solid var(--secondary-color);
            vertical-align: middle;
        }

        thead th {
            background-color: var(--accent-color);
            color: white;
            position: sticky;
            top: 0;
        }
        
        tbody tr:nth-child(odd) {
            background-color: var(--primary-color);
        }
        
        tbody tr:nth-child(even) {
            background-color: #222;
        }

        .player-name-input {
            width: 90%;
            padding: 5px;
            background-color: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--secondary-color);
            border-radius: 4px;
            text-align: center;
        }
        
        .manual-input-wrapper {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .manual-input {
            width: 60px;
            padding: 5px;
            text-align: center;
            background-color: #444;
            color: white;
            border: 1px solid var(--accent-color);
            border-radius: 4px;
        }
        .manual-input:focus {
            outline: 2px solid var(--accent-color);
            box-shadow: 0 0 8px var(--accent-color);
        }
        .manual-input:disabled {
            background-color: transparent;
            border: none;
            color: var(--text-color);
        }

        .winner-1 { font-weight: bold; color: var(--winner1); }
        .winner-2 { font-weight: bold; color: var(--winner2); }
        .winner-3 { font-weight: bold; color: var(--winner3); }

        .win-criteria {
            font-size: 0.8em;
            color: #ccc;
            white-space: nowrap;
        }
        
        .play-order-indicator {
            font-size: 0.75em;
            color: #aaa;
            display: block;
        }

        .footer {
            text-align: center;
            margin-top: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
        }

        .btn-file {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            font-weight: bold;
            display: inline-block;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Sorteio de Rodadas</h1>

        <!-- PAINEL DO LOBBY -->
        <div id="lobbyPanel" class="panel">
            <label for="drawSelector">Sorteios Salvos:</label>
            <select id="drawSelector"></select>
            <button id="loadDrawBtn">Carregar Sorteio</button>
            <button id="createDrawBtn">Novo Sorteio</button>
        </div>

        <!-- PAINEL DE CRIAÇÃO DE SORTEIO -->
        <div id="newDrawPanel" class="panel" style="display: none;">
            <h2>Criar Novo Sorteio</h2>
            <div class="form-group">
                <label for="newDrawNameInput">Nome do Sorteio:</label>
                <input type="text" id="newDrawNameInput" placeholder="Ex: Sorteio de Férias">
            </div>
            <div class="button-group">
                <button id="saveNewDrawBtn">Salvar Novo Sorteio</button>
                <button id="cancelNewDrawBtn" class="secondary">Cancelar</button>
            </div>
            <p id="newDrawError" style="color: var(--error-color);"></p>
        </div>

        <!-- CONTEÚDO DO SORTEIO CARREGADO -->
        <div id="drawContent" style="display: none; width: 100%;">
            <!-- PAINEL DE CONFIGURAÇÃO DO SORTEIO -->
            <div id="configPanel" class="panel">
                <div class="config-grid">
                    <div class="form-group">
                        <label for="numPlayers">Nº de participantes</label>
                        <input type="number" id="numPlayers" value="3" min="3">
                        <label for="playerNames" style="margin-top: 15px;">Nomes (um por linha ou separados por vírgula)</label>
                        <textarea id="playerNames" placeholder="Ex: Ana, Beto, Carol"></textarea>
                    </div>
                    <div class="form-group">
                        <div class="checkbox-group" title="Quando marcado, a cada rodada é sorteado se vence o MAIOR ou o MENOR número.">
                            <input type="checkbox" id="randomizeWinCriteria">
                            <label for="randomizeWinCriteria">Randomizar critério de vitória</label>
                        </div>
                        <div class="switch-group">
                            <label class="switch">
                                <input type="checkbox" id="manualModeToggle">
                                <span class="slider"></span>
                            </label>
                            <label for="manualModeToggle">Entrada manual por turno</label>
                        </div>
                        <div id="syncStatus" aria-live="polite">Carregando...</div>
                        <div id="lastUpdate" style="font-size: 0.8em; color: #aaa;"></div>
                    </div>
                    <div class="form-group">
                        <label>Ações</label>
                        <div class="button-group">
                            <button id="createTableBtn">Criar tabela</button>
                            <button id="randomizeOrderBtn">Randomizar ordem</button>
                            <button id="generateRoundBtn" disabled>Gerar rodada 1</button>
                            <button id="generateAllBtn" disabled>Gerar todas restantes</button>
                            <button id="resetBtn" class="danger" disabled>Resetar sorteio</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- TABELA PRINCIPAL -->
            <div class="panel table-container" id="tablePanel">
                <table id="resultsTable">
                    <thead></thead>
                    <tbody></tbody>
                </table>
            </div>
            
            <!-- RODAPÉ -->
            <div class="footer panel" id="footerPanel">
                <button id="exportCsvBtn">Exportar CSV</button>
                <div class="file-input-wrapper">
                    <span class="btn-file">Importar CSV</span>
                    <input type="file" id="importCsvInput" accept=".csv,text/csv">
                </div>
            </div>
        </div>
    </div>

    <script>
    const LOBBY_ENDPOINT = 'https://api.npoint.io/3b4acdc21fbf5889f820';
    const NPOINT_PROXY_URL = 'https://npoint-proxy.githuberzinho.workers.dev/npoint-documents';
    
    let currentDrawEndpoint = '';
    let lobbyData = { draws: [] }; 

    document.addEventListener('DOMContentLoaded', () => {
        // --- ELEMENTOS DO DOM ---
        const lobbyPanel = document.getElementById('lobbyPanel');
        const newDrawPanel = document.getElementById('newDrawPanel');
        const drawContent = document.getElementById('drawContent');
        const drawSelector = document.getElementById('drawSelector');
        const loadDrawBtn = document.getElementById('loadDrawBtn');
        const createDrawBtn = document.getElementById('createDrawBtn');
        const newDrawNameInput = document.getElementById('newDrawNameInput');
        const saveNewDrawBtn = document.getElementById('saveNewDrawBtn');
        const cancelNewDrawBtn = document.getElementById('cancelNewDrawBtn');
        const newDrawError = document.getElementById('newDrawError');
        const numPlayersInput = document.getElementById('numPlayers');
        const playerNamesTextarea = document.getElementById('playerNames');
        const randomizeWinCriteriaCheckbox = document.getElementById('randomizeWinCriteria');
        const manualModeToggle = document.getElementById('manualModeToggle');
        const createTableBtn = document.getElementById('createTableBtn');
        const randomizeOrderBtn = document.getElementById('randomizeOrderBtn');
        const generateRoundBtn = document.getElementById('generateRoundBtn');
        const generateAllBtn = document.getElementById('generateAllBtn');
        const resetBtn = document.getElementById('resetBtn');
        const syncStatusEl = document.getElementById('syncStatus');
        const lastUpdateEl = document.getElementById('lastUpdate');
        const tableThead = document.querySelector('#resultsTable thead');
        const tableTbody = document.querySelector('#resultsTable tbody');
        const exportCsvBtn = document.getElementById('exportCsvBtn');
        const importCsvInput = document.getElementById('importCsvInput');

        let state = null; 
        let tableCreated = false;
        let isSaving = false;
        let pollIntervalId = null;

        // --- FUNÇÕES UTILITÁRIAS ---
        const getRandomInt = (min, max) => {
            const range = max - min + 1;
            const buffer = new Uint32Array(1);
            window.crypto.getRandomValues(buffer);
            return min + (buffer[0] % range);
        };
        const shuffleArray = (array) => {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = getRandomInt(0, i);
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        };
        const updateSyncStatus = (status, message) => {
            syncStatusEl.dataset.status = status;
            syncStatusEl.textContent = message;
        };

        // --- LÓGICA DO LOBBY ---
        async function loadLobby() {
            try {
                const response = await fetch(LOBBY_ENDPOINT);
                if (!response.ok) throw new Error("Não foi possível carregar o lobby.");
                const data = await response.json();
                lobbyData = data && Array.isArray(data.draws) ? data : { draws: [] }; 
                populateDrawSelector();
            } catch (error) {
                console.error("Erro no Lobby:", error);
                lobbyPanel.innerHTML = `<strong>Erro ao carregar o Lobby. Verifique a URL e a conexão. (${LOBBY_ENDPOINT})</strong>`;
            }
        }

        function populateDrawSelector() {
            drawSelector.innerHTML = '<option value="">-- Selecione um Sorteio --</option>';
            lobbyData.draws.forEach(draw => {
                const option = document.createElement('option');
                option.value = draw.id;
                const date = new Date(draw.createdAt).toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo' });
                option.textContent = `${draw.name} (${date})`;
                drawSelector.appendChild(option);
            });
        }

        async function saveLobby() {
            try {
                const response = await fetch(LOBBY_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(lobbyData)
                });
                if (!response.ok) throw new Error("Falha ao salvar o lobby.");
                return true;
            } catch (error) {
                console.error("Erro ao salvar lobby:", error);
                return false;
            }
        }

        async function createNewBinViaProxy() {
            const initialContents = JSON.stringify({ "csv": "" });
            const payload = { contents: initialContents };
            try {
                const res = await fetch(NPOINT_PROXY_URL, {
                    method: 'POST',
                    headers: { 'content-type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!res.ok) throw new Error(`Proxy returned status ${res.status}`);
                const data = await res.json();
                return (data && data.token) ? data.token : null;
            } catch (e) {
                console.error('Error creating new bin via proxy:', e);
                return null;
            }
        }
        
        async function addNewDrawToLobby(id, name) {
            const newDraw = { name, id, createdAt: new Date().toISOString() };
            lobbyData.draws.push(newDraw);
            const success = await saveLobby();
            if (success) {
                newDrawPanel.style.display = 'none';
                lobbyPanel.style.display = 'flex';
                populateDrawSelector();
                drawSelector.value = id;
                await loadSelectedDraw();
            } else {
                 newDrawError.textContent = "Não foi possível salvar o novo sorteio no lobby.";
                 lobbyData.draws.pop();
            }
        }

        async function loadSelectedDraw() {
            if (pollIntervalId) clearInterval(pollIntervalId);
            pollIntervalId = null;
            const selectedId = drawSelector.value;
            if (!selectedId) {
                state = null;
                drawContent.style.display = 'none';
                return;
            }
            currentDrawEndpoint = `https://api.npoint.io/${selectedId}`;
            await fetchRemoteState();
            drawContent.style.display = 'block';
            pollIntervalId = setInterval(pollForChanges, 7000);
        }

        // --- LÓGICA DE PERSISTÊNCIA (CSV) ---
        function serializeToCsv() {
            if (!state) return "";
            const configLine = `CONFIG,rounds,${state.config.rounds},players,${state.config.players},randomize_win_criteria,${state.config.randomize_win_criteria},updatedAt,${state.config.updatedAt}`;
            const columnsLine = `COLUMNS,${state.columns.join(',')}`;
            const namesLine = `NAMES,${state.names.join(',')}`;
            const roundsLines = state.roundsData.map((round) => {
                const roundNum = `R${state.roundsData.indexOf(round) + 1}`;
                const criteria = round.criteria || '';
                const scores = round.scores.join(',');
                const order = round.order && round.order.length > 0 ? `ORDER,${round.order.join(',')}` : 'ORDER,';
                const inputOrder = round.inputOrder ? `INPUT_ORDER,${round.inputOrder.join(',')}` : 'INPUT_ORDER,';
                const tempScores = round.tempScoresForOrder ? `TEMP_SCORES,${round.tempScoresForOrder.join(',')}` : 'TEMP_SCORES,';
                return [roundNum, criteria, scores, order, inputOrder, tempScores].join(',');
            }).join('\n');
            return [configLine, columnsLine, namesLine, roundsLines].join('\n');
        }

        function parseFromCsv(csvString) {
            if (!csvString) return null;
            const lines = csvString.trim().split('\n');
            const newState = { config: {}, columns: [], names: [], roundsData: [] };
            lines.forEach(line => {
                const parts = line.split(',');
                const type = parts[0];
                if (type === 'CONFIG') {
                    newState.config = { rounds: parseInt(parts[2], 10), players: parseInt(parts[4], 10), randomize_win_criteria: parts[6], updatedAt: parts[8] };
                } else if (type === 'COLUMNS') {
                    newState.columns = parts.slice(1);
                } else if (type === 'NAMES') {
                    newState.names = parts.slice(1);
                } else if (type.startsWith('R')) {
                    const roundIndex = parseInt(type.substring(1), 10) - 1;
                    if (!newState.roundsData[roundIndex]) newState.roundsData[roundIndex] = { scores: [], order: [], inputOrder: null, tempScoresForOrder: null };
                    const orderIndex = parts.indexOf('ORDER');
                    const inputOrderIndex = parts.indexOf('INPUT_ORDER');
                    const tempScoresIndex = parts.indexOf('TEMP_SCORES');
                    newState.roundsData[roundIndex].criteria = parts[1];
                    newState.roundsData[roundIndex].scores = parts.slice(2, orderIndex).map(s => s ? parseInt(s, 10) : null);
                    if (orderIndex > -1) newState.roundsData[roundIndex].order = parts.slice(orderIndex + 1, inputOrderIndex).map(o => o ? parseInt(o, 10) : null);
                    if (inputOrderIndex > -1) newState.roundsData[roundIndex].inputOrder = parts.slice(inputOrderIndex + 1, tempScoresIndex).filter(o => o).map(o => parseInt(o, 10));
                    if (tempScoresIndex > -1) newState.roundsData[roundIndex].tempScoresForOrder = parts.slice(tempScoresIndex + 1).filter(s => s).map(s => parseInt(s, 10));
                }
            });
            if (isNaN(newState.config.rounds)) return null;
            newState.roundsData.length = newState.config.rounds;
            for(let i = 0; i < newState.config.rounds; i++) {
                if(!newState.roundsData[i]) {
                    newState.roundsData[i] = { scores: Array(newState.config.players).fill(null), order: [], inputOrder: null, tempScoresForOrder: null };
                }
            }
            return newState;
        }

        // --- LÓGICA DE REDE ---
        async function fetchRemoteState() {
            if (!currentDrawEndpoint) return;
            try {
                updateSyncStatus('updating', 'Carregando dados...');
                const response = await fetch(currentDrawEndpoint);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                state = parseFromCsv(data.csv || "");
                tableCreated = state && state.columns && state.columns.length > 0;
                if (!state) {
                    state = { config: { rounds: 12, players: 3, randomize_win_criteria: 'N', updatedAt: new Date().toISOString() }, columns: [], names: [], roundsData: [] };
                    tableCreated = false;
                }
                renderUI();
                updateSyncStatus('synced', 'Sincronizado');
            } catch (error) {
                console.error("Erro ao buscar dados:", error);
                updateSyncStatus('offline', 'Falha ao carregar. Verifique a URL e a conexão.');
            }
        }

        async function saveRemoteState() {
            if (!currentDrawEndpoint || !state) return;
            if (isSaving) return;
            isSaving = true;
            updateSyncStatus('saving', 'Salvando...');
            state.config.updatedAt = new Date().toISOString();
            try {
                const response = await fetch(currentDrawEndpoint, {
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ csv: serializeToCsv() })
                });
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                updateSyncStatus('synced', 'Sincronizado');
            } catch (error) {
                console.error("Erro ao salvar dados:", error);
                updateSyncStatus('error', 'Falha ao salvar.');
            } finally {
                isSaving = false;
            }
        }

        async function pollForChanges() {
            if (!currentDrawEndpoint || !state) return;
            try {
                const response = await fetch(currentDrawEndpoint);
                if (!response.ok) return; 
                const data = await response.json();
                const remoteState = parseFromCsv(data.csv || "");
                if (remoteState && remoteState.config.updatedAt > state.config.updatedAt) {
                    updateSyncStatus('updating', 'Atualizando...');
                    state = remoteState;
                    tableCreated = state.columns.length > 0;
                    renderUI();
                    updateSyncStatus('synced', 'Sincronizado');
                }
            } catch (error) {
                console.error("Erro durante o polling:", error);
            }
        }

        // --- LÓGICA DO SORTEIO ---
        function determineWinners(scores, criteria) {
            let indexedScores = scores.map((score, index) => ({ score, index }))
                                      .filter(item => item.score !== null && !isNaN(item.score));
            indexedScores.sort((a, b) => {
                let diff = (criteria === 'MAX') ? b.score - a.score : a.score - b.score;
                return diff !== 0 ? diff : (getRandomInt(1, 100) > 50 ? 1 : -1);
            });
            const places = Array(scores.length).fill(null);
            indexedScores.slice(0, 3).forEach((item, i) => { places[item.index] = i + 1; });
            return { order: places, orderedIndices: indexedScores.map(item => item.index) };
        }
        
        function generateRound(roundIndex) {
            const roundData = state.roundsData[roundIndex];
            if (!roundData.criteria) roundData.criteria = (state.config.randomize_win_criteria === 'Y') ? (getRandomInt(0, 1) === 0 ? 'MIN' : 'MAX') : 'MAX';
            roundData.scores = Array.from({ length: state.config.players }, () => getRandomInt(1, 100));
            const { order } = determineWinners(roundData.scores, roundData.criteria);
            roundData.order = order;
        }

        function startManualRound(roundIndex) {
            const roundData = state.roundsData[roundIndex];
            const tempScores = Array.from({ length: state.config.players }, () => getRandomInt(1, 100));
            if (!roundData.criteria) roundData.criteria = (state.config.randomize_win_criteria === 'Y') ? (getRandomInt(0, 1) === 0 ? 'MIN' : 'MAX') : 'MAX';
            const { orderedIndices } = determineWinners(tempScores, roundData.criteria);
            roundData.tempScoresForOrder = tempScores;
            roundData.inputOrder = orderedIndices;
            roundData.scores.fill(null);
            roundData.order = [];
            saveRemoteState().then(renderUI);
        }

        // --- RENDERIZAÇÃO DA UI ---
        function renderUI() {
            if (!state) return;

            if (!tableCreated) {
                numPlayersInput.value = state.config.players;
                randomizeWinCriteriaCheckbox.checked = state.config.randomize_win_criteria === 'Y';
                playerNamesTextarea.value = state.names.join('\n');
            }
            
            if (state.config.updatedAt) lastUpdateEl.textContent = `Última atualização: ${new Date(state.config.updatedAt).toLocaleString()}`;
            tableThead.innerHTML = '';
            tableTbody.innerHTML = '';
            
            if (!tableCreated) {
                updateButtonStates();
                return;
            }
            const headerRow1 = document.createElement('tr');
            const headerRow2 = document.createElement('tr');
            headerRow1.innerHTML = '<th></th>';
            headerRow2.innerHTML = '<th>SORTEIO</th>';
            state.columns.forEach((colId, index) => {
                const th1 = document.createElement('th');
                th1.textContent = state.names[index] || `Nome ${index + 1}`;
                headerRow1.appendChild(th1);
                const th2 = document.createElement('th');
                th2.textContent = `PESSOA ${index + 1}`;
                headerRow2.appendChild(th2);
            });
            headerRow1.innerHTML += '<th></th>';
            headerRow2.innerHTML += '<th>CRITÉRIO</th>';
            tableThead.appendChild(headerRow1);
            tableThead.appendChild(headerRow2);
            state.roundsData.forEach((round, roundIndex) => {
                const tr = document.createElement('tr');
                tr.innerHTML = `<td><strong>R${roundIndex + 1}</strong></td>`;
                const isManualModeActive = manualModeToggle.checked;
                let nextPlayerToInput = -1;
                if (isManualModeActive && round.inputOrder && round.inputOrder.length > 0) {
                    const nextIndex = round.inputOrder.find(idx => round.scores[idx] === null || round.scores[idx] === '');
                    if (typeof nextIndex !== 'undefined') nextPlayerToInput = nextIndex;
                }
                (round.scores || []).forEach((score, playerIndex) => {
                    const td = document.createElement('td');
                    if (isManualModeActive && round.inputOrder && round.inputOrder.length > 0) {
                        const playOrder = round.inputOrder.indexOf(playerIndex) + 1;
                        if (score === null || score === '') {
                            const wrapper = document.createElement('div');
                            wrapper.className = 'manual-input-wrapper';
                            
                            const input = document.createElement('input');
                            input.type = "text";
                            input.className = 'manual-input';
                            input.dataset.round = roundIndex;
                            input.dataset.player = playerIndex;
                            input.disabled = playerIndex !== nextPlayerToInput;
                            if (!input.disabled) setTimeout(() => input.focus(), 0);
                            wrapper.appendChild(input);

                            if (playerIndex === nextPlayerToInput) {
                                const confirmBtn = document.createElement('button');
                                confirmBtn.textContent = '✔';
                                confirmBtn.className = 'confirm-btn';
                                confirmBtn.onclick = () => handleManualInputChange({ target: input });
                                wrapper.appendChild(confirmBtn);
                            }
                            td.appendChild(wrapper);

                            const tempScore = round.tempScoresForOrder ? round.tempScoresForOrder[playerIndex] : '-';
                            if (playOrder > 0) {
                                const indicator = document.createElement('span');
                                indicator.className = 'play-order-indicator';
                                indicator.innerHTML = `(${playOrder}º a jogar - Sorteado: ${tempScore})`;
                                td.appendChild(indicator);
                            }
                        } else {
                            td.innerHTML = `${score} ${round.order[playerIndex] ? `<span class="winner-${round.order[playerIndex]}">[${round.order[playerIndex]}º]</span>` : ''}`;
                        }
                    } else {
                        let content = '';
                        if (score !== null && score !== '') {
                            content = `${score} `;
                            const place = round.order[playerIndex];
                            if (place) content += `<span class="winner-${place}">[${place}º]</span>`;
                        }
                        td.innerHTML = content;
                    }
                    tr.appendChild(td);
                });
                const criteriaTd = document.createElement('td');
                if(round.criteria) criteriaTd.innerHTML = `<span class="win-criteria">${round.criteria === 'MAX' ? 'MAIOR' : 'MENOR'} vence</span>`;
                tr.appendChild(criteriaTd);
                tableTbody.appendChild(tr);
            });
            updateButtonStates();
        }
        
        async function handleManualInputChange(e) {
            const roundIndex = parseInt(e.target.dataset.round, 10);
            const playerIndex = parseInt(e.target.dataset.player, 10);
            const value = e.target.value; // Get the raw string value

            state.roundsData[roundIndex].scores[playerIndex] = value;
            
            // A round is complete when all players have an entry (initial state is null, empty string is a valid entry)
            const isRoundComplete = !state.roundsData[roundIndex].scores.some(s => s === null);
            if (isRoundComplete) {
                const roundData = state.roundsData[roundIndex];
                // In manual mode, the input is the result. No winners to determine.
                // Clear the temporary ordering data to signify the manual round is done.
                roundData.inputOrder = null;
                roundData.tempScoresForOrder = null;
            }
            
            await saveRemoteState();
            renderUI();
        }

        function findNextRound() {
            if (!state || !state.roundsData) return -1;
            return state.roundsData.findIndex(r => r.scores.every(s => s === null));
        }

        function updateButtonStates() {
            if (!state) return;
            const nextRound = findNextRound();
            numPlayersInput.disabled = tableCreated;
            createTableBtn.disabled = tableCreated;
            randomizeOrderBtn.disabled = !playerNamesTextarea.value.trim() || tableCreated;
            generateAllBtn.disabled = !tableCreated || nextRound === -1 || manualModeToggle.checked;
            resetBtn.disabled = !tableCreated;
            let roundInProgressManually = false;
            if (manualModeToggle.checked && tableCreated && nextRound > -1) {
                const roundData = state.roundsData[nextRound];
                roundInProgressManually = roundData && Array.isArray(roundData.inputOrder);
            }
            generateRoundBtn.disabled = !tableCreated || nextRound === -1 || roundInProgressManually;
            if (nextRound !== -1) {
                generateRoundBtn.textContent = `Gerar rodada ${nextRound + 1}`;
            } else if(tableCreated) {
                generateRoundBtn.textContent = 'Completo!';
            }
        }

        // --- MANIPULADORES DE EVENTOS ---

        loadDrawBtn.addEventListener('click', loadSelectedDraw);
        createDrawBtn.addEventListener('click', () => {
            lobbyPanel.style.display = 'none';
            newDrawPanel.style.display = 'block';
            newDrawError.textContent = '';
            newDrawNameInput.value = '';
        });
        cancelNewDrawBtn.addEventListener('click', () => {
            newDrawPanel.style.display = 'none';
            lobbyPanel.style.display = 'flex';
        });

        saveNewDrawBtn.addEventListener('click', async () => {
            const newName = newDrawNameInput.value.trim();
            if (!newName) {
                newDrawError.textContent = "O nome do sorteio é obrigatório.";
                return;
            }
            saveNewDrawBtn.disabled = true;
            newDrawError.textContent = "Criando novo sorteio...";
            const newId = await createNewBinViaProxy();
            if (newId) {
                await addNewDrawToLobby(newId, newName);
            } else {
                newDrawError.textContent = "Falha ao criar o novo sorteio. Tente novamente.";
            }
            saveNewDrawBtn.disabled = false;
        });

        createTableBtn.addEventListener('click', () => {
            const numPlayers = parseInt(numPlayersInput.value, 10);
            if (numPlayers < 3) {
                updateSyncStatus('error', "O nº de participantes deve ser no mínimo 3.");
                return;
            }
            let names = playerNamesTextarea.value.trim().split(/[\n,]/).map(name => name.trim().toUpperCase()).filter(name => name);
            if (names.length !== numPlayers) {
                updateSyncStatus('error', `O nº de nomes (${names.length}) deve ser igual ao nº de participantes (${numPlayers}).`);
                return;
            }
            tableCreated = true;
            state.config.players = numPlayers;
            state.config.randomize_win_criteria = randomizeWinCriteriaCheckbox.checked ? 'Y' : 'N';
            state.columns = Array.from({ length: numPlayers }, (_, i) => `P${i + 1}`);
            state.names = shuffleArray(names.slice(0, numPlayers));
            state.roundsData = Array.from({ length: state.config.rounds }, () => ({
                criteria: null, scores: Array(numPlayers).fill(null), order: [], inputOrder: null, tempScoresForOrder: null
            }));
            saveRemoteState().then(renderUI);
        });
        
        randomizeOrderBtn.addEventListener('click', () => {
             let names = playerNamesTextarea.value.trim().split(/[\n,]/).map(name => name.trim()).filter(name => name);
            playerNamesTextarea.value = shuffleArray(names).join('\n');
        });

        generateRoundBtn.addEventListener('click', () => {
            const nextRound = findNextRound();
            if (nextRound !== -1) {
                if(manualModeToggle.checked) {
                    startManualRound(nextRound);
                } else {
                    generateRound(nextRound);
                    saveRemoteState().then(renderUI);
                }
            }
        });
        
        generateAllBtn.addEventListener('click', () => {
            let nextRound = findNextRound();
            while(nextRound !== -1) {
                generateRound(nextRound);
                nextRound = findNextRound();
            }
            saveRemoteState().then(renderUI);
        });

        resetBtn.addEventListener('click', () => {
            state.roundsData.forEach(round => {
                round.scores.fill(null);
                round.order = [];
                round.inputOrder = null;
                round.tempScoresForOrder = null;
            });
            saveRemoteState().then(renderUI);
        });
        
        manualModeToggle.addEventListener('change', () => {
            updateButtonStates();
            if (tableCreated) { // Só re-renderiza a tabela se ela existir
                renderUI();
            }
        });
        
        exportCsvBtn.addEventListener('click', () => {
            const csvContent = serializeToCsv();
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            const drawName = (lobbyData.draws.find(d => d.id === currentDrawEndpoint.split('/').pop()) || {}).name || 'sorteio';
            link.setAttribute("download", `${drawName.replace(/\s/g, '_')}_${new Date().toISOString().split('T')[0]}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        importCsvInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const newState = parseFromCsv(e.target.result);
                    if (!newState) throw new Error("Arquivo CSV inválido.");
                    state = newState;
                    tableCreated = true;
                    saveRemoteState().then(renderUI);
                } catch (error) {
                    console.error("Erro ao importar CSV:", error);
                    updateSyncStatus('error', "Erro ao importar o arquivo.");
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        });

        // --- INICIALIZAÇÃO ---
        function init() {
            loadLobby();
        }
        init();
        
    });
    </script>

</body>
</html></script>

</body>
</html>
